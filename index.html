<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Chess Move Tree</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboard2@0.5.0/dist/chessboard2.min.css">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f8f9fa;
      color: #333;
      display: grid;
      grid-template-columns: 400px 1fr;
      height: 100vh;
      overflow: hidden;
    }

    #boardContainer {
      display: flex;
      flex-direction: column;
      padding: 20px;
      border-right: 2px solid #dee2e6;
      background: white;
    }

    #board {
      width: 360px;
      height: 360px;
      margin: 0 auto 20px;
      border: 2px solid #007bff;
      border-radius: 8px;
    }

    #controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }

    button:hover {
      background: #0056b3;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #resetBtn {
      background: #dc3545;
    }

    #resetBtn:hover {
      background: #c82333;
    }

    #copyAcnBtn {
      background: #28a745;
    }

    #copyAcnBtn:hover {
      background: #218838;
    }

    #copyAcnBtn.copied {
      background: #6c757d;
    }

    #status {
      text-align: center;
      padding: 12px;
      background: #e9ecef;
      border-radius: 4px;
      font-weight: 500;
      margin-bottom: 20px;
    }

    #gameInfo {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      border: 1px solid #dee2e6;
    }

    #gameInfo h3 {
      margin: 0 0 10px 0;
      color: #007bff;
      font-size: 16px;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      font-size: 14px;
    }

    .info-value {
      font-weight: 600;
      color: #007bff;
    }

    #sidebar {
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      background: white;
    }

    #treeHeader {
      padding: 20px;
      border-bottom: 1px solid #dee2e6;
      background: #f8f9fa;
    }

    #treeHeader h2 {
      margin: 0 0 15px 0;
      color: #333;
      font-size: 20px;
    }

    #treeControls {
      display: flex;
      gap: 10px;
    }

    #treeContainer {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    #treeContainer::-webkit-scrollbar {
      width: 8px;
    }

    #treeContainer::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    #treeContainer::-webkit-scrollbar-thumb {
      background: #007bff;
      border-radius: 4px;
    }

    #treeContainer::-webkit-scrollbar-thumb:hover {
      background: #0056b3;
    }

    /* Tree Styles */
    .tree-node {
      margin: 4px 0;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      background: #f8f9fa;
      border: 1px solid transparent;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .tree-node:hover {
      background: #e9ecef;
      border-color: #007bff;
    }

    .tree-node.active {
      background: #007bff;
      color: white;
      border-color: #0056b3;
    }

    .tree-node.expandable::before {
      content: "▶";
      color: #007bff;
      font-size: 10px;
      width: 12px;
      text-align: center;
    }

    .tree-node.expanded::before {
      content: "▼";
    }

    .tree-node.active::before {
      color: white;
    }

    .tree-children {
      margin-left: 20px;
      border-left: 2px solid #dee2e6;
      padding-left: 15px;
      margin-top: 4px;
    }

    .tree-children.hidden {
      display: none;
    }

    .move-text {
      font-weight: 600;
    }

    .move-info {
      color: #6c757d;
      font-size: 12px;
      margin-left: auto;
    }

    .tree-node.active .move-info {
      color: rgba(255, 255, 255, 0.8);
    }

    /* Depth-based styling */
    .depth-0 { font-size: 15px; }
    .depth-1 { font-size: 14px; }
    .depth-2 { font-size: 13px; }
    .depth-3, .depth-4, .depth-5 { font-size: 12px; }
    .depth-6, .depth-7, .depth-8, .depth-9, .depth-10 { font-size: 11px; }

    @media (max-width: 768px) {
      body {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr;
      }

      #boardContainer {
        border-right: none;
        border-bottom: 2px solid #dee2e6;
        padding: 15px;
      }

      #board {
        width: 280px;
        height: 280px;
      }

      #sidebar {
        height: auto;
      }

      #treeContainer {
        max-height: 50vh;
      }

      #controls {
        justify-content: center;
      }
    }

    /* Copy notification */
    .copy-notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #28a745;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      font-weight: 500;
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .copy-notification.show {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <div id="boardContainer">
    <div id="board"></div>
    <div id="status">White to move</div>
    <div id="controls">
      <button id="resetBtn">Reset</button>
      <button id="undoBtn">Undo</button>
      <button id="copyAcnBtn">Copy ACN</button>
    </div>
    <div id="gameInfo">
      <h3>Game Info</h3>
      <div class="info-item">
        <span>Turn:</span>
        <span class="info-value" id="turnInfo">1</span>
      </div>
      <div class="info-item">
        <span>Moves:</span>
        <span class="info-value" id="moveCount">0</span>
      </div>
      <div class="info-item">
        <span>Tree Depth:</span>
        <span class="info-value" id="treeDepth">0</span>
      </div>
    </div>
  </div>

  <div id="sidebar">
    <div id="treeHeader">
      <h2>Move Tree</h2>
      <div id="treeControls">
        <button id="expandAllBtn">Expand All</button>
        <button id="collapseAllBtn">Collapse All</button>
      </div>
    </div>
    <div id="treeContainer">
      <div id="moveTree"></div>
    </div>
  </div>

  <div id="copyNotification" class="copy-notification">
    ACN copied to clipboard!
  </div>

  <script src="https://unpkg.com/@chrisoakman/chessboard2@0.5.0/dist/chessboard2.min.js"></script>
  <script type="module">
    import { Chess } from 'https://cdn.jsdelivr.net/npm/chess.js@1.4.0/+esm';

    let game = new Chess();
    let gameHistory = [];
    let currentPath = [];
    let maxDepthReached = 0;
    let moveNodes = new Map(); // Track all move nodes for easier management
    
    const board = Chessboard2('board', {
      position: game.fen(),
      draggable: false,
      orientation: 'white'
    });

    const moveTree = document.getElementById('moveTree');
    const statusEl = document.getElementById('status');
    const turnInfo = document.getElementById('turnInfo');
    const moveCount = document.getElementById('moveCount');
    const treeDepth = document.getElementById('treeDepth');

    function updateGameInfo() {
      const turn = Math.ceil(game.history().length / 2);
      const moves = game.history().length;
      
      turnInfo.textContent = turn;
      moveCount.textContent = moves;
      treeDepth.textContent = maxDepthReached;

      if (game.isCheckmate()) {
        statusEl.textContent = `${game.turn() === 'w' ? 'Black' : 'White'} wins!`;
        statusEl.style.background = '#28a745';
        statusEl.style.color = 'white';
      } else if (game.isDraw()) {
        statusEl.textContent = 'Game is a draw';
        statusEl.style.background = '#ffc107';
        statusEl.style.color = 'black';
      } else if (game.inCheck()) {
        statusEl.textContent = `${game.turn() === 'w' ? 'White' : 'Black'} is in check`;
        statusEl.style.background = '#dc3545';
        statusEl.style.color = 'white';
      } else {
        statusEl.textContent = `${game.turn() === 'w' ? 'White' : 'Black'} to move`;
        statusEl.style.background = '#e9ecef';
        statusEl.style.color = '#333';
      }

      document.getElementById('undoBtn').disabled = gameHistory.length === 0;
      document.getElementById('copyAcnBtn').disabled = game.history().length === 0;
    }

    function createMoveNode(move, fen, depth, parentContainer) {
      maxDepthReached = Math.max(maxDepthReached, depth);
      
      const nodeDiv = document.createElement('div');
      nodeDiv.className = `tree-node depth-${Math.min(depth, 10)}`;
      
      const moveNumber = Math.ceil((new Chess(fen).history().length + 1) / 2);
      const isWhite = new Chess(fen).turn() === 'w';
      const displayText = depth === 0 ? 
        `${moveNumber}${isWhite ? '.' : '...'} ${move.san}` : 
        move.san;
      
      const moveSpan = document.createElement('span');
      moveSpan.className = 'move-text';
      moveSpan.textContent = displayText;
      nodeDiv.appendChild(moveSpan);
      
      // Add move info
      const infoSpan = document.createElement('span');
      infoSpan.className = 'move-info';
      const info = [];
      if (move.san.includes('#')) info.push('mate');
      else if (move.san.includes('+')) info.push('check');
      if (move.captured) info.push('capture');
      if (move.promotion) info.push('promotion');
      infoSpan.textContent = info.join(', ');
      nodeDiv.appendChild(infoSpan);
      
      // Check if this move leads to more moves
      const testGame = new Chess(fen);
      testGame.move(move.san);
      const hasChildren = testGame.moves().length > 0 && !testGame.isGameOver();
      
      if (hasChildren) {
        nodeDiv.classList.add('expandable');
      }
      
      const nodeId = `${fen}-${move.san}`;
      nodeDiv.dataset.nodeId = nodeId;
      nodeDiv.dataset.fen = fen;
      nodeDiv.dataset.move = move.san;
      nodeDiv.dataset.depth = depth;
      
      moveNodes.set(nodeId, {
        element: nodeDiv,
        move: move,
        fen: fen,
        depth: depth,
        expanded: false,
        hasChildren: hasChildren
      });
      
      nodeDiv.addEventListener('click', (e) => {
        e.stopPropagation();
        handleMoveClick(nodeId);
      });
      
      parentContainer.appendChild(nodeDiv);
      return nodeDiv;
    }

    function handleMoveClick(nodeId) {
      const nodeData = moveNodes.get(nodeId);
      if (!nodeData) return;
      
      // If node has children and is expandable, toggle expansion
      if (nodeData.hasChildren && nodeData.element.classList.contains('expandable')) {
        toggleNodeExpansion(nodeId);
      }
      
      // Make the move
      makeMove(nodeData.fen, nodeData.move);
      
      // Update active state
      document.querySelectorAll('.tree-node.active').forEach(el => el.classList.remove('active'));
      nodeData.element.classList.add('active');
      
      // Scroll to view
      nodeData.element.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    function toggleNodeExpansion(nodeId) {
      const nodeData = moveNodes.get(nodeId);
      if (!nodeData || !nodeData.hasChildren) return;
      
      const childrenContainer = nodeData.element.nextElementSibling;
      
      if (nodeData.expanded) {
        // Collapse
        if (childrenContainer && childrenContainer.classList.contains('tree-children')) {
          childrenContainer.classList.add('hidden');
        }
        nodeData.element.classList.remove('expanded');
        nodeData.expanded = false;
      } else {
        // Expand
        if (childrenContainer && childrenContainer.classList.contains('tree-children')) {
          childrenContainer.classList.remove('hidden');
        } else {
          // Create children for the first time
          expandNode(nodeId);
        }
        nodeData.element.classList.add('expanded');
        nodeData.expanded = true;
      }
    }

    function expandNode(nodeId) {
      const nodeData = moveNodes.get(nodeId);
      if (!nodeData || !nodeData.hasChildren) return;
      
      // Create the new game state after this move
      const newGame = new Chess(nodeData.fen);
      newGame.move(nodeData.move.san);
      
      // Create children container
      const childrenContainer = document.createElement('div');
      childrenContainer.className = 'tree-children';
      
      // Insert after the node
      nodeData.element.parentNode.insertBefore(childrenContainer, nodeData.element.nextSibling);
      
      // Get all possible moves and create nodes for them
      const moves = newGame.moves({ verbose: true });
      
      // Sort moves by a simple heuristic
      moves.sort((a, b) => {
        let scoreA = 0, scoreB = 0;
        
        // Prioritize captures
        if (a.captured) scoreA += 10;
        if (b.captured) scoreB += 10;
        
        // Prioritize checks
        if (a.san.includes('+')) scoreA += 5;
        if (b.san.includes('+')) scoreB += 5;
        
        // Prioritize checkmates
        if (a.san.includes('#')) scoreA += 100;
        if (b.san.includes('#')) scoreB += 100;
        
        return scoreB - scoreA;
      });
      
      moves.forEach(move => {
        createMoveNode(move, newGame.fen(), nodeData.depth + 1, childrenContainer);
      });
    }

    function makeMove(fen, moveSan) {
      const newGame = new Chess(fen);
      newGame.move(moveSan);
      
      game = newGame;
      board.setPosition(game.fen());
      
      gameHistory.push({
        fen: game.fen(),
        move: moveSan,
        path: [...currentPath, moveSan]
      });
      currentPath.push(moveSan);
      
      updateGameInfo();
    }

    function generateAcn() {
      const moves = game.history();
      if (moves.length === 0) {
        return "No moves played";
      }
      
      let acn = "";
      for (let i = 0; i < moves.length; i++) {
        if (i % 2 === 0) {
          // White move - add move number
          acn += `${Math.floor(i / 2) + 1}. ${moves[i]}`;
        } else {
          // Black move
          acn += ` ${moves[i]}`;
        }
        
        // Add space after each complete move pair or if it's the last move
        if (i % 2 === 1 || i === moves.length - 1) {
          acn += " ";
        }
      }
      
      // Add game result if applicable
      if (game.isCheckmate()) {
        acn += game.turn() === 'w' ? '0-1' : '1-0';
      } else if (game.isDraw()) {
        acn += '1/2-1/2';
      }
      
      return acn.trim();
    }

    function copyAcnToClipboard() {
      const acn = generateAcn();
      const copyBtn = document.getElementById('copyAcnBtn');
      const notification = document.getElementById('copyNotification');
      
      navigator.clipboard.writeText(acn).then(() => {
        // Show success feedback
        copyBtn.classList.add('copied');
        copyBtn.textContent = 'Copied!';
        
        notification.classList.add('show');
        
        setTimeout(() => {
          copyBtn.classList.remove('copied');
          copyBtn.textContent = 'Copy ACN';
          notification.classList.remove('show');
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy ACN: ', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = acn;
        document.body.appendChild(textArea);
        textArea.select();
        try {
          document.execCommand('copy');
          copyBtn.textContent = 'Copied!';
          setTimeout(() => {
            copyBtn.textContent = 'Copy ACN';
          }, 2000);
        } catch (fallbackErr) {
          console.error('Fallback copy failed: ', fallbackErr);
        }
        document.body.removeChild(textArea);
      });
    }

    function initializeTree() {
      moveTree.innerHTML = '';
      moveNodes.clear();
      
      const moves = game.moves({ verbose: true });
      
      // Sort opening moves
      moves.sort((a, b) => {
        const openingMoves = ['e4', 'e5', 'd4', 'd5', 'Nf3', 'Nc6', 'Nf6', 'Nc3'];
        const scoreA = openingMoves.includes(a.san) ? 10 : 0;
        const scoreB = openingMoves.includes(b.san) ? 10 : 0;
        return scoreB - scoreA;
      });
      
      moves.forEach(move => {
        createMoveNode(move, game.fen(), 0, moveTree);
      });
    }

    function resetGame() {
      game = new Chess();
      gameHistory = [];
      currentPath = [];
      maxDepthReached = 0;
      
      board.setPosition(game.fen());
      updateGameInfo();
      initializeTree();
    }

    function undoMove() {
      if (gameHistory.length > 0) {
        gameHistory.pop();
        currentPath.pop();
        
        if (gameHistory.length > 0) {
          const lastState = gameHistory[gameHistory.length - 1];
          game = new Chess(lastState.fen);
        } else {
          game = new Chess();
        }
        
        board.setPosition(game.fen());
        updateGameInfo();
        
        // Update active state
        document.querySelectorAll('.tree-node.active').forEach(el => el.classList.remove('active'));
      }
    }

    function expandAll() {
      const expandBtn = document.getElementById('expandAllBtn');
      expandBtn.disabled = true;
      expandBtn.textContent = 'Expanding...';
      
      const expandableNodes = Array.from(moveNodes.values()).filter(node => 
        node.hasChildren && !node.expanded
      );
      
      let processed = 0;
      function expandNext() {
        if (processed >= expandableNodes.length) {
          expandBtn.disabled = false;
          expandBtn.textContent = 'Expand All';
          updateGameInfo();
          return;
        }
        
        const nodeData = expandableNodes[processed];
        const nodeId = Array.from(moveNodes.entries())
          .find(([_, data]) => data === nodeData)?.[0];
        
        if (nodeId) {
          toggleNodeExpansion(nodeId);
        }
        
        processed++;
        setTimeout(expandNext, 10);
      }
      
      expandNext();
    }

    function collapseAll() {
      moveNodes.forEach((nodeData, nodeId) => {
        if (nodeData.expanded) {
          toggleNodeExpansion(nodeId);
        }
      });
    }

    // Event listeners
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('copyAcnBtn').addEventListener('click', copyAcnToClipboard);
    document.getElementById('expandAllBtn').addEventListener('click', expandAll);
    document.getElementById('collapseAllBtn').addEventListener('click', collapseAll);

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        switch(e.key) {
          case 'z':
            e.preventDefault();
            undoMove();
            break;
          case 'r':
            e.preventDefault();
            resetGame();
            break;
          case 'c':
            if (game.history().length > 0) {
              e.preventDefault();
              copyAcnToClipboard();
            }
            break;
        }
      }
    });

    // Initialize
    initializeTree();
    updateGameInfo();
  </script>
</body>
</html>
